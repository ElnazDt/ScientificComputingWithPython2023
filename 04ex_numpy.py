# -*- coding: utf-8 -*-
"""04ex_numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vTJDE03PcwK8uKa2sS8G---eaqJZ5KcD

1\. **Reductions**

Given the following matrix:

```python
m = np.arange(12).reshape((3,4))
```

   1. find the total mean
   2. find the mean for each row and column
"""

import numpy as np

m = np.arange(12).reshape((3,4))
print(m, '\n')
print('total mean :', m.mean())
print('mean along columns :', m.mean(axis=0))
print('mean along rows :', m.mean(axis=1))

"""2\. **Outer product**

Find the outer product of the following vectors:

```python
u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])
```

Use different methods to do this:

   1. Using the function `outer` in numpy
   2. Using a nested `for` loop or a list comprehension
   3. Using numpy broadcasting operations
"""

# using outer function
u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])
pr=np.outer(u, v)
print(pr)

# using a nested for loop or a list comprehension
prd =np.array([list(x*v) for x in u])
print(prd)

#Using numpy broadcasting operations
prod_broad = np.tile(u,(len(v),1)).T * v
print(prod_broad)

"""3\. **Matrix masking**

Create a $10 \times 6$ matrix of float random numbers, distributed between 0 and 3 according to a flat distribution.

After creating the matrix, set all entries $< 0.3$ to zero using a mask.
"""

import numpy.random as npr
npr.seed(5671)
m=npr.rand(10, 6)*3
print('matrix :', '\n', m, '\n')

#mask = (m<0.3)
m[m<0.3]=0
print('masked m :','\n', m)

"""4\. **Trigonometric functions**

Use `np.linspace` to create an array of 100 numbers between $0$ and $2\pi$ (inclusive).

  * Extract every 10th element using the slice notation
  * Reverse the array using the slice notation
  * Extract elements where the absolute difference between the `sin` and `cos` functions evaluated for that element is $< 0.1$
  * **Optional**: make a plot showing the `sin` and `cos` functions and indicate graphically (with a line or a marker) where they are close
"""

import math
from matplotlib import pyplot as plt
l = np.linspace(0, 2*math.pi, 100)
#la = l.reshape(10, 10)
print(l, '\n')

l_slice = l[10:101:10]
print('extracted elements: ',l_slice, '\n')
reversed_arr = l[::-1]
print('reversed array: ',reversed_arr)
abs_array = l[np.absolute(np.cos(l)-np.sin(l))<0.1]
print('elements where absolute difference of sin and cos is less than 0.1: ',abs_array)



plt.title("plot")
plt.xlabel("x axis")
plt.ylabel("y axis")
plt.plot(l,np.sin(l),l,np.cos(l) )
plt.scatter(abs_array,np.sin(abs_array))
plt.scatter(abs_array,np.cos(abs_array))

plt.show()

"""5\. **Matrices**

Create a matrix that shows the $10 \times 10$ multiplication table.

 * Find the trace of the matrix
 * Extract the anti-diagonal matrix (this should be ```array([10, 18, 24, 28, 30, 30, 28, 24, 18, 10])```)
 * Extract the diagonal offset by 1 upwards (this should be ```array([ 2,  6, 12, 20, 30, 42, 56, 72, 90])```)
"""

r = np.arange(1, 11)
mult_table = r*r[:, None]
print(mult_table, '\n')

print(' trace of the matrix :', mult_table.trace(), '\n')

anti_diag = np.fliplr(mult_table).diagonal()
print(' anti-diagonal matrix :', anti_diag, '\n')

diag = mult_table.diagonal(1)
print('diagonal offset by 1 upwards :', diag)

"""6\. **Broadcasting**

Use broadcasting to create a grid of distances.

Route 66 crosses the following cities in the US: Chicago, Springfield, Saint-Louis, Tulsa, Oklahoma City, Amarillo, Santa Fe, Albuquerque, Flagstaff, Los Angeles.

The corresponding positions in miles are: `0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448`

  * Build a 2D grid of distances among each city along Route 66
  * Convert the distances in km
"""

row = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
grid = np.absolute(row-row[:,None])
print('grid of distances :', '\n', grid, '\n')

km_grid = np.round(grid*1.60934)
print('grid of distances in KM :', '\n', km_grid)

"""7\. **Prime numbers sieve**

Compute the prime numbers in the 0-N (start with N=99) range with a sieve (mask).

  * Construct a shape (N,) boolean array, which is the mask
  * Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element
  * Apply the mask to obtain an array of ordered prime numbers
  * Check the performances (with `timeit`); how does it scale with N?
  * Implement the optimization suggested in the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)
"""

def primeNumbers(n):
  mask = [True for _ in range(n+1)]
  mask[0] = mask[1] = False

  m=2
  for m in range(2, n):
    if (mask[m]==True) :
      for m in range(m * m, n+1, m):
        mask[m] = False
  m += 1
  return np.arange(0,n+1)[mask]

print(primeNumbers(100))

"""8\. **Diffusion using random walk**

Consider a simple random walk process: at each step in time, a walker jumps right or left (+1 or -1) with equal probability. The goal is to find the typical distance from the origin of many random walkers after a given amount of time.

*Hint*: create a 2D array where each row represents a walker, and each column represents a time step.

  * Take 1000 walkers and let them walk for 200 steps
  * Use `randint` to create a 2D array of size $walkers \times steps$ with values -1 or 1
  * Calculate the walking distances for each walker (e.g. by summing the elements in each row)
  * Take the square of the previously-obtained array (element-wise)
  * Compute the mean of the squared distances at each step (i.e. the mean along the columns)
  * **Optional**: plot the average distances ($\sqrt(distance^2)$) as a function of time (step)
"""

import numpy.random as npr
from matplotlib import pyplot as plt
w = 1000
s = 200
arr = npr.randint(-1, 1, size=(w,s))
arr[arr==0] = 1
print(arr, '\n')

# sm = arr.sum(axis=1)
for i in range(1,s):
  arr[:,i] = arr[:,i] + arr[:,i-1]

print('distance in each step',arr, '\n')
sqr = arr*arr
print('square of previously obtained array',sqr)
mean_steps = sqr.mean(axis=0)
print('mean square of each step',mean_steps);

radical =np.sqrt(mean_steps)
print('mean square of each step',radical)

x = np.arange(1,s+1)

plt.title("plot")
plt.xlabel("step axis caption")
plt.ylabel("mean square of each step axis caption")
plt.plot(x,radical)
plt.show()